
// Custom function to encode WAV from the Float32Array output by the VAD library.

// There are libraries that accomplish this, but here's the code, generated by ChatGPT...
function float32ToWav(floatArray, sampleRate) {
  const buffer = new ArrayBuffer(44 + floatArray.length * 2);
  const view = new DataView(buffer);

  // Set up the RIFF chunk descriptor
  writeString(view, 0, "RIFF");
  view.setUint32(4, 36 + floatArray.length * 2, true);
  writeString(view, 8, "WAVE");

  // Set up the fmt sub-chunk
  writeString(view, 12, "fmt ");
  view.setUint32(16, 16, true);
  view.setUint16(20, 1, true);
  view.setUint16(22, 1, true);
  view.setUint32(24, sampleRate, true);
  view.setUint32(28, sampleRate * 2, true);
  view.setUint16(32, 2, true);
  view.setUint16(34, 16, true);

  // Set up the data sub-chunk
  writeString(view, 36, "data");
  view.setUint32(40, floatArray.length * 2, true);

  // Convert floatArray to Int16Array
  const intArray = new Int16Array(floatArray.length);
  for (let i = 0; i < floatArray.length; i++) {
    const floatValue = Math.max(-1, Math.min(1, floatArray[i]));
    intArray[i] = floatValue < 0 ? floatValue * 0x8000 : floatValue * 0x7FFF;
  }

  // Write audio data
  const dataView = new DataView(buffer, 44);
  for (let i = 0; i < intArray.length; i++) {
    dataView.setInt16(i * 2, intArray[i], true);
  }

  return buffer;
}

function writeString(view, offset, string) {
  for (let i = 0; i < string.length; i++) {
    view.setUint8(offset + i, string.charCodeAt(i));
  }
}


// Voice Activity Detection (VAD) loop
async function vadSTT() {
  const myvad = await vad.MicVAD.new({
    onSpeechStart: () => {
      console.log("Speech start detected")
    },
    onSpeechEnd: async (audio) => {
      let wav = float32ToWav(audio, 16000)
      let blobber = new Blob([wav], { type: 'audio/wav' });
      console.log(blobber)

      //DEBUG
      //const downloadLink = document.createElement('a');
      //downloadLink.href = URL.createObjectURL(blobber);
      //downloadLink.download = 'transcription.wav';
      //downloadLink.click();

      // BENCHMARK: Record the start time
      const startTime = performance.now();

      let output = '';

      fetch('http://localhost:3157/transcribe', {
      //fetch('/stt', {  //Caddy proxy
        method: 'POST',
        headers: {
          'Content-Type': 'audio/wav'
        },
        body: blobber
      })
        .then(response => response.json())
        .then(data => {
          // BENCHMARK: Record end time and calculate latency
          const endTime = performance.now();
          const latency = endTime - startTime;
          console.log('STT Delay: ' + latency);

          // display the transcribed text and language on the web page
          const transcribedSegments = data.transcribed_segments;
          const language = data.language;

          // All together now!
          output = data.transcribed_segments.map(segment => segment.text).join('');
          //console.log(output)

      //HACKY PUB/SUB EMITTER
      // Publish output to an event == emitter.emit('eventChannel', output);
      // Using the DOM (body) to pass events for zero imports/dependencies
          const STTevent = new Event('STT');
          document.body.setAttribute('data-stt', output);
          document.body.dispatchEvent(STTevent);

        })
        .catch(error => { 
          const STTevent = new Event('STT');
          document.body.setAttribute('data-stt', error);
          document.body.dispatchEvent(STTevent);
          console.error(error) 
        });
    }
  })
  myvad.start()
  
    //IS BOT SPEAKING? - Toggle prevents feedback/self-STT bug.
    let speaking = false;

    // While speaking, stop listening
    audioElement.onplay = () => {
      speaking = true;
      myvad.pause()
      //recognition.stop(); //WEBSPEECH ONLY
      console.log("speaking");
    };

    // When finished, start listening again
    audioElement.onended = () => {
      speaking = false;
      myvad.start()
      //recognition.start(); //WEBSPEECH ONLY
      console.log("listening");
    };

    // Catch TTS errors & restart VAD
    document.body.addEventListener('TTS', (event) => {
      speaking = false;
      myvad.start()
    });

}
//vadSTT() call this loop at the end of the main script.

